mod client;
mod dynamic_analysis;
mod idl;
mod static_analysis;

pub use idl::Idl;

use anyhow::{anyhow, Result};
use dynamic_analysis::extract_args;
use dynamic_analysis::extract_types;
use idl::{InstructionInfo, Metadata};
use log::debug;
use solana_sbpf::program::FunctionRegistry;
use solana_sbpf::program::SBPFVersion;
use solana_sbpf::{ebpf, static_analysis::Analysis};
use solana_sdk::hash::hash;
use static_analysis::{
    extract_accounts, extract_ix_accounts, find_account_deserializer, find_instruction_handlers,
    generate_call_graph,
};
use std::collections::{BTreeMap, BTreeSet};
use std::str::FromStr;

/// Public API for Range.
/// `program_id_str` should be base58 program id (e.g. "So111...").
/// `executable_data` is the raw bytes of the loaded upgradeable program.
pub fn reverse_engineer_idl(program_id_str: &str, executable_data: &[u8]) -> Result<Idl> {
    // parse program_id from string using *this crate's* solana_sdk
    let program_id = solana_sdk::pubkey::Pubkey::from_str(program_id_str)
        .map_err(|e| anyhow!("invalid program id {program_id_str}: {e}"))?;

    // === paste/refactor the pipeline you showed me ===
    // 1. Check anchor
    if !static_analysis::is_anchor_program(executable_data) {
        return Err(anyhow!("Program is not an anchor program"));
    }

    // 2. Load sbpf executable
    let executable = static_analysis::load_executable(executable_data, &program_id)?;

    let sbpf_version = executable.get_sbpf_version();
    debug_assert!(!sbpf_version.static_syscalls());
    let function_registry = executable.get_function_registry();

    // 3. Run rbpf analysis
    // Run sbpf built-in analysis
    let analysis = Analysis::from_executable(&executable)
        .map_err(|e| anyhow!("Failed to analyze program: {e}"))?;

    // Get ptr to instruction mapping
    let (_program_vm_addr, program) = executable.get_text_bytes();
    let mut instructions: BTreeMap<usize, ebpf::Insn> = BTreeMap::new();
    let mut insn_ptr: usize = 0;
    while insn_ptr * ebpf::INSN_SIZE < program.len() {
        let mut insn = ebpf::get_insn_unchecked(program, insn_ptr);
        if insn.opc == ebpf::LD_DW_IMM {
            insn_ptr += 1;
            if insn_ptr * ebpf::INSN_SIZE >= program.len() {
                break;
            }
            ebpf::augment_lddw_unchecked(program, &mut insn);
        }
        instructions.insert(insn.ptr, insn);
        insn_ptr += 1;
    }

    // Use the start of the next function as the end of the current function
    let function_ranges: BTreeMap<_, _> = analysis
        .functions
        .keys()
        .zip(
            analysis
                .functions
                .keys()
                .skip(1)
                .chain(std::iter::once(&insn_ptr)),
        )
        .map(|(start, end)| (*start, (*start, *end)))
        .collect();

    let (call_graph, reference_graph) =
        generate_call_graph(&executable, &function_ranges, &instructions)?;

    let (instruction_handlers, possible_signer_error) = find_instruction_handlers(
        &executable,
        &function_ranges,
        &instructions,
        executable_data,
    )?;

    let deserializers = find_account_deserializer(
        &function_ranges,
        &instructions,
        &reference_graph,
        executable_data,
    );

    debug!("possible_signer_error: {:?}", possible_signer_error);

    let signer_try_from_pc = match possible_signer_error {
        Some(pc) => reference_graph.get(&pc).and_then(|x| x.first().cloned()),
        None => None,
    };
    debug!("signer_try_from_pc: {:?}", signer_try_from_pc);

    let instruction_infos = build_instruction_infos(
        instruction_handlers,
        &call_graph,
        &function_ranges,
        &instructions,
        &analysis,
        function_registry,
        &sbpf_version,
        executable_data,
        signer_try_from_pc,
    )?;

    let idl = Idl {
        address: program_id.to_string(),
        metadata: Metadata {
            name: "IDL".to_string(),
            version: "1.0.0".to_string(),
            spec: "0.1.0".to_string(),
            description: "Generated by IDL Guesser".to_string(),
        },
        instructions: instruction_infos,
        accounts: extract_accounts(&function_ranges, &instructions, executable_data),
        errors: vec![],
        types: extract_types(executable_data, &deserializers),
    };

    Ok(idl)
}

#[allow(clippy::too_many_arguments)]
fn build_instruction_infos(
    instruction_handlers: BTreeMap<String, usize>,
    call_graph: &BTreeMap<usize, BTreeSet<usize>>,
    function_ranges: &BTreeMap<usize, (usize, usize)>,
    instructions: &BTreeMap<usize, ebpf::Insn>,
    analysis: &Analysis,
    function_registry: &FunctionRegistry<usize>,
    sbpf_version: &SBPFVersion,
    executable_data: &[u8],
    signer_try_from_pc: Option<usize>,
) -> Result<Vec<InstructionInfo>> {
    let mut out = Vec::new();

    for (instruction_name, function_start) in instruction_handlers {
        debug!("");
        debug!(
            "Instruction candidate '{}' @ {}",
            instruction_name, function_start
        );

        // ---- 1. get the Insn meta for this handler ----
        let insn_meta = instructions.get(&function_start).ok_or_else(|| {
            anyhow!(
                "missing instruction metadata for handler '{}' (pc={})",
                instruction_name,
                function_start
            )
        })?;

        debug!("Handler ptr = {}", insn_meta.ptr);

        // ---- 2. compute discriminator ----
        let mut discriminator = [0u8; 8];
        discriminator.copy_from_slice(
            &hash(format!("global:{instruction_name}").as_bytes()).to_bytes()[..8],
        );

        let new_fn_tree = BTreeSet::new();

        // ---- 3. figure out best accounts list ----
        // call_graph[function_start] are the callees we consider "validator-style" functions
        let best_accounts_result = call_graph
            .get(&function_start)
            .unwrap_or(&new_fn_tree)
            .iter()
            .filter_map(|callee_pc| {
                // Get this callee's [start,end) range
                let (start, end) = match function_ranges.get(callee_pc) {
                    Some(range) => *range,
                    None => {
                        debug!(
                            "No function range for callee {} while analyzing '{}'",
                            callee_pc, instruction_name
                        );
                        return None;
                    }
                };

                // Build list of &ebpf::Insn for that callee
                let callee_insns: Vec<&ebpf::Insn> = instructions
                    .range(start..end)
                    .map(|(_, insn)| insn)
                    .collect();

                // Try to extract accounts for this callee
                let extracted_accounts = extract_ix_accounts(
                    analysis,
                    &callee_insns,
                    function_registry,
                    sbpf_version,
                    executable_data,
                    signer_try_from_pc,
                )
                .unwrap_or_default();

                Some((callee_pc, extracted_accounts))
            })
            // choose the callee that produced the most accounts (Anchor pattern)
            .max_by_key(|(_, accounts)| accounts.len());

        // If we couldn't extract any account metas at all, that's suspicious.
        let accounts = match best_accounts_result {
            Some((_pc, accounts)) => accounts,
            None => {
                return Err(anyhow!(
                    "failed to extract accounts for instruction '{}' (pc={})",
                    instruction_name,
                    function_start
                ));
            }
        };

        // ---- 4. infer args via dynamic analysis ----
        let args = extract_args(executable_data, function_start);

        // ---- 5. push InstructionInfo ----
        out.push(InstructionInfo {
            name: instruction_name,
            discriminator,
            accounts,
            args,
        });
    }

    Ok(out)
}
